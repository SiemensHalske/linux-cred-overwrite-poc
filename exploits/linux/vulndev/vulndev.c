// vulndev.c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define DEVICE_NAME "vulndev"
#define CLASS_NAME  "vuln"

// Define our vulnerable IOCTL command
#define VULN_IOCTL_WRITE _IOW('v', 0x01, struct aw_struct)


char test_buffer[16] = "ORIGINAL";
EXPORT_SYMBOL(test_buffer);

struct aw_struct {
    void *where;   // Kernel address to write to (unchecked)
    void *what;    // Pointer to data in user space to write
    size_t len;    // Number of bytes to write
};

static int major_number;
static struct class*  vuln_class  = NULL;
static struct device* vuln_device = NULL;
static struct cdev    vuln_cdev;

static int vuln_open(struct inode *inodep, struct file *filep)
{
    printk(KERN_INFO "vulndev: Device opened\n");
    return 0;
}

static int vuln_release(struct inode *inodep, struct file *filep)
{
    printk(KERN_INFO "vulndev: Device closed\n");
    return 0;
}

static long vuln_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct aw_struct data;

    printk(KERN_INFO "IOCTL cmd received: 0x%x\n", cmd);

    switch(cmd) {
        case VULN_IOCTL_WRITE:
            printk(KERN_INFO "VULN_IOCTL_WRITE matched.\n");

            if (copy_from_user(&data, (void __user *)arg, sizeof(data))) {
                printk(KERN_ALERT "Error: copy_from_user failed (struct)\n");
                return -EFAULT;
            }

            printk(KERN_INFO "Payload received: where=%px, what=%px, len=%zu\n",
                   data.where, data.what, data.len);

            if (copy_from_user(data.where, data.what, data.len)) {
                printk(KERN_ALERT "Error: copy_from_user failed (data payload)\n");
                return -EFAULT;
            }

            printk(KERN_INFO "Successfully wrote payload to kernel memory.\n");
            break;

        default:
            printk(KERN_ALERT "Invalid IOCTL command\n");
            return -EINVAL;
    }
    return 0;
}


static struct file_operations fops = {
    .owner          = THIS_MODULE,
    .open           = vuln_open,
    .release        = vuln_release,
    .unlocked_ioctl = vuln_ioctl,
};

static int __init vulndev_init(void)
{
    printk(KERN_INFO "VULN_IOCTL_WRITE kernel-side: 0x%x\n", VULN_IOCTL_WRITE);
    int ret;
    dev_t dev_no;

    // Dynamically allocate a major number
    ret = alloc_chrdev_region(&dev_no, 0, 1, DEVICE_NAME);
    if (ret < 0) {
        printk(KERN_ALERT "vulndev: Failed to allocate a major number\n");
        return ret;
    }
    major_number = MAJOR(dev_no);
    printk(KERN_INFO "vulndev: Registered with major number %d\n", major_number);

    // Create device class (using only the class name)
    vuln_class = class_create(CLASS_NAME);
    if (IS_ERR(vuln_class)) {
        unregister_chrdev_region(MKDEV(major_number, 0), 1);
        printk(KERN_ALERT "vulndev: Failed to register device class\n");
        return PTR_ERR(vuln_class);
    }
    printk(KERN_INFO "vulndev: Device class registered correctly\n");

    // Create device
    vuln_device = device_create(vuln_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
    if (IS_ERR(vuln_device)) {
        class_destroy(vuln_class);
        unregister_chrdev_region(MKDEV(major_number, 0), 1);
        printk(KERN_ALERT "vulndev: Failed to create the device\n");
        return PTR_ERR(vuln_device);
    }
    printk(KERN_INFO "vulndev: Device created correctly\n");

    // Initialize and add cdev
    cdev_init(&vuln_cdev, &fops);
    ret = cdev_add(&vuln_cdev, dev_no, 1);
    if (ret < 0) {
        device_destroy(vuln_class, MKDEV(major_number, 0));
        class_destroy(vuln_class);
        unregister_chrdev_region(MKDEV(major_number, 0), 1);
        printk(KERN_ALERT "vulndev: Failed to add cdev\n");
        return ret;
    }

    printk(KERN_INFO "vulndev: Module loaded successfully\n");
    return 0;
}


static void __exit vulndev_exit(void)
{
    cdev_del(&vuln_cdev);
    device_destroy(vuln_class, MKDEV(major_number, 0));
    class_destroy(vuln_class);
    unregister_chrdev_region(MKDEV(major_number, 0), 1);
    printk(KERN_INFO "vulndev: Module unloaded\n");
}

module_init(vulndev_init);
module_exit(vulndev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A vulnerable character device for arbitrary kernel write (PoC)");
